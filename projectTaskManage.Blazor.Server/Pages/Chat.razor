@using DevExpress.ExpressApp
@using projectTaskManage.Module.BusinessObjects
@page "/chat"
@inject LangChainService LangChainService
@inject IObjectSpaceFactory ObjectSpaceFactory

<h3>AI Chat</h3>

<textarea @bind="UserMessage" rows="3" style="width:100%"></textarea>
<button @onclick="SendMessage">Send</button>

@if (ResponseMessage != null)
{
    <div class="mt-3">
        <strong>Result:</strong>
        <pre>@ResponseMessage</pre>
    </div>
}

@code {
    string UserMessage;
    string ResponseMessage;

    async Task SendMessage()
    {
        var result = await LangChainService.ParseAsync(UserMessage);

        if (result != null)
        {
            await ExecuteCrud(result);
            ResponseMessage = "Operation completed successfully.";
        }
        else
        {
            ResponseMessage = "Error parsing command.";
        }
    }

    private async Task ExecuteCrud(CrudCommand command)
    {
        var entityType = ResolveEntityType(command.Entity);

        if (entityType == null)
        {
            ResponseMessage = $"Unknown entity: {command.Entity}";
            return;
        }

        using var objectSpace = ObjectSpaceFactory.CreateObjectSpace(entityType);

        switch (command.Action.ToLower())
        {
            case "create":
                await HandleCreate(command, entityType, objectSpace);
                break;

            case "read":
                await HandleRead(entityType, objectSpace);
                break;

            case "update":
                await HandleUpdate(command, entityType, objectSpace);
                break;

            case "delete":
                await HandleDelete(command, entityType, objectSpace);
                break;

            default:
                ResponseMessage = $"Unknown action: {command.Action}";
                break;
        }
    }

	// This method handles the "create" action by instantiating a new entity, setting its properties, and saving it to the database.
    private async Task HandleCreate(CrudCommand command, Type entityType, IObjectSpace objectSpace)
    {
        var entity = objectSpace.CreateObject(entityType);

        foreach (var field in command.Fields)
        {
            var prop = entityType.GetProperty(
                field.Key,
                System.Reflection.BindingFlags.IgnoreCase |
                System.Reflection.BindingFlags.Public |
                System.Reflection.BindingFlags.Instance
            );

            if (prop != null && field.Value != null)
{
    // If property is a class (navigation property)
    if (!prop.PropertyType.IsPrimitive &&
        prop.PropertyType != typeof(string) &&
        !prop.PropertyType.IsEnum &&
        !prop.PropertyType.IsValueType)
    {
        // Assume AI sends ID of related entity
        var relatedId = Guid.Parse(field.Value.ToString());

        var relatedObject = objectSpace.GetObjectByKey(
            prop.PropertyType,
            relatedId
        );

        if (relatedObject != null)
        {
            prop.SetValue(entity, relatedObject);
        }
        else
        {
            ResponseMessage = $"Related {prop.PropertyType.Name} not found.";
            return;
        }
    }
    else
    {
        var value = ConvertJsonValue(field.Value, prop.PropertyType);
        prop.SetValue(entity, value);
    }
}

        }

        objectSpace.CommitChanges();
        ResponseMessage = $"{command.Entity} created successfully.";
        await Task.CompletedTask;
    }


	// This method handles the "read" action by retrieving all records of the specified entity type and returning them as a JSON string.
    private async Task HandleRead(Type entityType, IObjectSpace objectSpace)
    {
        var objects = objectSpace.GetObjects(entityType);
        ResponseMessage = $"Found {objects.Count} record(s).";
        await Task.CompletedTask;
    }


	// This method handles the "update" action by finding an existing entity based on the provided criteria, updating its properties, and saving the changes to the database.
    private async Task HandleUpdate(CrudCommand command, Type entityType, IObjectSpace objectSpace)
    {
        if (!command.Fields.ContainsKey("id"))
        {
            ResponseMessage = "ID is required for update.";
            return;
        }

        var id = Guid.Parse(command.Fields["id"].ToString());
        var entity = objectSpace.GetObjectByKey(entityType, id);

        if (entity == null)
        {
            ResponseMessage = "Record not found.";
            return;
        }

        foreach (var field in command.Fields)
        {
            if (field.Key.ToLower() == "id") continue;

            var prop = entityType.GetProperty(
                field.Key,
                System.Reflection.BindingFlags.IgnoreCase |
                System.Reflection.BindingFlags.Public |
                System.Reflection.BindingFlags.Instance
            );

            if (prop != null && field.Value != null)
            {
                var value = ConvertJsonValue(field.Value, prop.PropertyType);
                prop.SetValue(entity, value);
            }
        }

        objectSpace.CommitChanges();
        ResponseMessage = $"{command.Entity} updated successfully.";
        await Task.CompletedTask;
    }


	// This method handles the "delete" action by finding an existing entity based on the provided criteria and deleting it from the database.
    private async Task HandleDelete(CrudCommand command, Type entityType, IObjectSpace objectSpace)
    {
        if (!command.Fields.ContainsKey("id"))
        {
            ResponseMessage = "ID is required for delete.";
            return;
        }

        var id = Guid.Parse(command.Fields["id"].ToString());
        var entity = objectSpace.GetObjectByKey(entityType, id);

        if (entity == null)
        {
            ResponseMessage = "Record not found.";
            return;
        }

        objectSpace.Delete(entity);
        objectSpace.CommitChanges();

        ResponseMessage = $"{command.Entity} deleted successfully.";
        await Task.CompletedTask;
    }


    // This method converts a JSON value to the specified target type, handling common types such as string, int, bool, and DateTime.
    private object ConvertJsonValue(object input, Type targetType)
    {
        if (input is System.Text.Json.JsonElement jsonElement)
        {
            switch (jsonElement.ValueKind)
            {
                case System.Text.Json.JsonValueKind.String:
                    return Convert.ChangeType(jsonElement.GetString(), targetType);

                case System.Text.Json.JsonValueKind.Number:
                    if (targetType == typeof(int))
                        return jsonElement.GetInt32();
                    if (targetType == typeof(long))
                        return jsonElement.GetInt64();
                    if (targetType == typeof(decimal))
                        return jsonElement.GetDecimal();
                    if (targetType == typeof(double))
                        return jsonElement.GetDouble();
                    break;

                case System.Text.Json.JsonValueKind.True:
                case System.Text.Json.JsonValueKind.False:
                    return jsonElement.GetBoolean();
            }
        }

        return Convert.ChangeType(input, targetType);
    }



    private Type ResolveEntityType(string entityName)
    {
        return entityName.ToLower() switch
        {
            "employee" => typeof(Employee),
            "project" => typeof(Project),
            "task" => typeof(ProjectTask),
            "projecttask" => typeof(ProjectTask),
            _ => null
        };
    }

}

